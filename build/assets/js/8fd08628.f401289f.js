"use strict";(self.webpackChunkx_1_docs=self.webpackChunkx_1_docs||[]).push([[489],{778:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/svm-vs-evm2-929b6e07092821eb21cb3a02c9d03d73.png"},2222:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/tpu-7ae15a930050e7c32a3566ac6f0304ab.png"},2894:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/thread-capacity-41e1efbef34788e378e439367cf1be6e.png"},4654:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core-concepts/technical-roadmap/svm-capacity-scaling","title":"SVM Capacity Scaling","description":"Unlocking Hardware Potential: Dynamic Thread Scaling in X1 Blockchain\'s Execution Scheduler","source":"@site/docs/core-concepts/technical-roadmap/svm-capacity-scaling.md","sourceDirName":"core-concepts/technical-roadmap","slug":"/core-concepts/technical-roadmap/svm-capacity-scaling","permalink":"/core-concepts/technical-roadmap/svm-capacity-scaling","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"description":"Unlocking Hardware Potential: Dynamic Thread Scaling in X1 Blockchain\'s Execution Scheduler"},"sidebar":"tutorialSidebar","previous":{"title":"Scaling Through Reductionism","permalink":"/core-concepts/technical-roadmap/scaling-through-reductionism"},"next":{"title":"Creating Programs","permalink":"/developing-programs/create-a-program"}}');var t=i(4848),a=i(8453);const r={description:"Unlocking Hardware Potential: Dynamic Thread Scaling in X1 Blockchain's Execution Scheduler"},c="SVM Capacity Scaling",o={},l=[{value:"Scheduling",id:"scheduling",level:2},{value:"Initiating the Transaction",id:"initiating-the-transaction",level:3},{value:"Multi-Thread Parallelization",id:"multi-thread-parallelization",level:3},{value:"Block Building &amp; Banking Stage",id:"block-building--banking-stage",level:2},{value:"Transaction Processing Stages",id:"transaction-processing-stages",level:3},{value:"Current Limitations in SVM Architecture",id:"current-limitations-in-svm-architecture",level:2},{value:"Key Issues:",id:"key-issues",level:3},{value:"X1 Blockchain\u2019s Solution: Dynamic Thread Scaling",id:"x1-blockchains-solution-dynamic-thread-scaling",level:2},{value:"Key Improvements:",id:"key-improvements",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"svm-capacity-scaling",children:"SVM Capacity Scaling"})}),"\n",(0,t.jsx)(n.h2,{id:"scheduling",children:"Scheduling"}),"\n",(0,t.jsx)(n.h3,{id:"initiating-the-transaction",children:"Initiating the Transaction"}),"\n",(0,t.jsx)(n.p,{children:"Once a user signs a transaction in their wallet, the wallet sends it to an X1 RPC server. RPC servers can be run by any validator. Upon receiving the transaction, the RPC server checks the leader schedule (determined once per epoch, about two days long) and forwards the transaction to the current leader as well as the next two leaders. The leader is responsible for producing a block for the current slot and is assigned four consecutive slots. Slots usually last around 400 milliseconds."}),"\n",(0,t.jsx)(n.p,{children:"Once the signed transaction reaches the current leader, it validates the transaction's signature and performs pre-processing before scheduling the transaction for execution."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:i(6492).A+"",width:"5188",height:"1584"})}),"\n",(0,t.jsx)(n.h3,{id:"multi-thread-parallelization",children:"Multi-Thread Parallelization"}),"\n",(0,t.jsxs)(n.p,{children:["Unlike the ",(0,t.jsx)(n.strong,{children:"EVM"}),", which is a single-threaded runtime that processes only one contract at a time, the ",(0,t.jsx)(n.strong,{children:"SVM"})," is multi-threaded, allowing it to process more transactions in significantly less time. Each thread contains a queue of transactions waiting to be executed, with transactions randomly assigned to a queue."]}),"\n",(0,t.jsxs)(n.p,{children:["The default scheduler implementation is multi-threaded, with each thread maintaining its own transaction queue. Transactions are randomly assigned to a queue and ordered by ",(0,t.jsx)(n.strong,{children:"priority fee"})," (fee paid per compute unit requested) and ",(0,t.jsx)(n.strong,{children:"time"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:i(778).A+"",width:"2070",height:"1600"})}),"\n",(0,t.jsx)(n.p,{children:"Notably, there is no global ordering of transactions queued for execution\u2014only local ordering within each thread\u2019s queue."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"block-building--banking-stage",children:"Block Building & Banking Stage"}),"\n",(0,t.jsxs)(n.p,{children:["Most blockchain networks construct full blocks before broadcasting them, a process known as ",(0,t.jsx)(n.strong,{children:"discrete block building"}),". In contrast, ",(0,t.jsx)(n.strong,{children:"X1 and Solana employ continuous block building"}),", dynamically assembling and streaming blocks as they are created. This approach significantly reduces latency."]}),"\n",(0,t.jsxs)(n.p,{children:["Each slot lasts ",(0,t.jsx)(n.strong,{children:"400 milliseconds"}),", and each leader is assigned ",(0,t.jsx)(n.strong,{children:"four consecutive slots (1.6 seconds)"})," before the role rotates. For a block to be accepted, all transactions within it must be valid and reproducible by other nodes."]}),"\n",(0,t.jsxs)(n.p,{children:["Two slots before assuming leadership, a validator halts transaction forwarding to prepare for the upcoming workload. During this time, ",(0,t.jsx)(n.strong,{children:"inbound traffic spikes"})," to over ",(0,t.jsx)(n.strong,{children:"one gigabyte per second"}),", as the entire network directs packets to the next leader."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:i(2222).A+"",width:"3834",height:"1877"})}),"\n",(0,t.jsx)(n.h3,{id:"transaction-processing-stages",children:"Transaction Processing Stages"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fetch Stage"})," \u2013 Transactions are received via ",(0,t.jsx)(n.strong,{children:"QUIC"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SigVerify Stage"})," \u2013 Signatures are validated, and duplicate transactions are removed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Banking Stage"})," \u2013 Transactions are processed in parallel and grouped into ",(0,t.jsx)(n.strong,{children:"ledger entries"})," (batches of 64 non-conflicting transactions)."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Parallel transaction processing is possible because each transaction ",(0,t.jsx)(n.strong,{children:"explicitly lists all accounts it will read and write to"}),". This design choice shifts complexity onto developers but enables the validator to avoid race conditions by only selecting non-conflicting transactions for execution in each entry."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:i(7185).A+"",width:"3834",height:"1874"})}),"\n",(0,t.jsx)(n.p,{children:"In the diagram above:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Thread 1"})," locks ",(0,t.jsx)(n.code,{children:"[a, b, c]"})," and ",(0,t.jsx)(n.code,{children:"[d]"})," but fails to lock ",(0,t.jsx)(n.code,{children:"[c, j]"})," and ",(0,t.jsx)(n.code,{children:"[f, g]"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Thread 2"})," locks ",(0,t.jsx)(n.code,{children:"[w]"})," and ",(0,t.jsx)(n.code,{children:"[x, y, z]"})," but fails to lock ",(0,t.jsx)(n.code,{children:"[c]"})," and ",(0,t.jsx)(n.code,{children:"[v]"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Non-conflicting transactions run in parallel, improving efficiency"}),", while conflicting transactions must be executed sequentially."]}),"\n",(0,t.jsxs)(n.p,{children:["The system uses ",(0,t.jsx)(n.strong,{children:"six threads for transaction processing"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Four threads handle normal transactions"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Two threads handle vote transactions"}),", which are essential to X1 and Solana\u2019s consensus mechanisms"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Once transactions are executed, their changes are finalized and stored in the blockchain state."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"current-limitations-in-svm-architecture",children:"Current Limitations in SVM Architecture"}),"\n",(0,t.jsxs)(n.p,{children:["Solana\u2019s ",(0,t.jsx)(n.strong,{children:"high throughput"})," is largely due to its parallel processing architecture. However, a major limitation is the ",(0,t.jsx)(n.strong,{children:"fixed number of banking threads"})," used for transaction execution."]}),"\n",(0,t.jsx)(n.h3,{id:"key-issues",children:"Key Issues:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Underutilization of Multi-Core Processors"})," \u2013 Modern processors often have ",(0,t.jsx)(n.strong,{children:"16, 32, or more cores"}),", but Solana limits banking threads to just ",(0,t.jsx)(n.strong,{children:"four"}),", wasting computational resources."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Execution Bottlenecks"})," \u2013 This artificial cap restricts transaction processing, leading to ",(0,t.jsx)(n.strong,{children:"higher latency and lower throughput"})," during peak network activity."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Limited Parallelism"})," \u2013 The effectiveness of Solana\u2019s parallel processing is reduced due to this limitation, preventing full optimization."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"x1-blockchains-solution-dynamic-thread-scaling",children:"X1 Blockchain\u2019s Solution: Dynamic Thread Scaling"}),"\n",(0,t.jsxs)(n.p,{children:["To address these inefficiencies, X1 Blockchain introduces ",(0,t.jsx)(n.strong,{children:"dynamic thread scaling"}),", which allows the number of banking threads to scale based on the CPU core count of the node."]}),"\n",(0,t.jsx)(n.h3,{id:"key-improvements",children:"Key Improvements:"}),"\n",(0,t.jsxs)(n.p,{children:["\u2714 ",(0,t.jsx)(n.strong,{children:"Adaptive Thread Allocation"})," \u2013 Banking threads are dynamically assigned based on available CPU cores. For example, a ",(0,t.jsx)(n.strong,{children:"32-core processor"})," can have up to ",(0,t.jsx)(n.strong,{children:"32 banking threads"}),", maximizing efficiency."]}),"\n",(0,t.jsxs)(n.p,{children:["\u2714 ",(0,t.jsx)(n.strong,{children:"Increased Parallelism"})," \u2013 More threads allow for ",(0,t.jsx)(n.strong,{children:"greater transaction throughput"}),", minimizing bottlenecks."]}),"\n",(0,t.jsxs)(n.p,{children:["\u2714 ",(0,t.jsx)(n.strong,{children:"Higher Throughput"})," \u2013 More transactions can be processed concurrently, reducing confirmation times, especially during peak network usage."]}),"\n",(0,t.jsxs)(n.p,{children:["\u2714 ",(0,t.jsx)(n.strong,{children:"Future-Proof Scalability"})," \u2013 As hardware advances, X1\u2019s execution scheduler will ",(0,t.jsx)(n.strong,{children:"automatically scale"}),", ensuring long-term performance and efficiency."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:i(2894).A+"",width:"4167",height:"1405"})}),"\n",(0,t.jsxs)(n.p,{children:["By eliminating ",(0,t.jsx)(n.strong,{children:"artificial constraints"})," on banking threads, X1 Blockchain ensures that ",(0,t.jsx)(n.strong,{children:"modern hardware is fully utilized"}),", making the network faster, more efficient, and scalable for future growth."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},6492:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/scheduling-2-7d779eaa1d678692bc4487292459d156.png"},7185:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/execution-threads-29fc5465ef15af4885069cfb63fe1c9b.png"},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>c});var s=i(6540);const t={},a=s.createContext(t);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);